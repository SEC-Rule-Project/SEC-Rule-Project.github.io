<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fe6f651491b6811d0d35b89c97914e20b8ffabc414924d5610e561abce6c01fe8ce941351874da1b66257c09a248f81d62a01d95473370aa2739b232f1a6ee32b1dd3ef114cb31dcd68186d23284bf033abf3d1e5ddf19d235fb357814309dc23c92f48bcf23bf87a528b4ebab994f8a3f3f84a66506522d0a6df59aeeb13b15267616903a2707e7ce06490396c7d478ccf0ef6fbd3e527e5d96b482cc221320c43ba0914bbcccaa151468de3030458de9faf659eb5345a049671e55b49098df26817a2733fb50d44f5cf028324a47daa7b85fe45713db0a45f3016a9a9a29c321af2801e6b7d9ab5189d4b47d1edac4299579851973be5fac882d3836e6bd53a34d147657f2020dfebd999078289fe8b3f7f55f0903f89febac5bcd0bef83efcb83ea58f267cea16b52c2846a2379151abdb2cf58882c882ca8e3a327103228539b123e0d9eacedc255606c1d632cccae12ce4f47584d59f64024fcd18dd2dd809d99457c42bd6be24517e56cdb9477768e187c50303ec2c766a1b9c33f8f3696f710952a9ca09b27c1c62e57e9ca12f1fc233e6190400186aa7616a92a23db0da08519a3789ff5235a86a4d56a53f6373f5e8542f3305b7aec6b2f29febe8c3144aaaf0416c4ecf81398ec199f913f44edbd6f97e298d7c67d8359a7086c61b0ac673ddd52973f8537e8a22b1e8383cef4b55ea66bb258076edf714af8103428b75e65a5ee6da88dec4fd4fe47a69cf43363c6ad5f12ad5a08d1bb0d5f1481a0143a2d18c7ed6da00fe0d1b1fee03983355a407f3a51a14480ca251f4456c501da4914cd8ff0da1f37770347e74a58eac8940c49dfa03a6b66909d7ca62b5537ff5026232144874047d8995b7021241e13185d8dfcbe448d17270c190955b08052576eafd47298dbda7ea37c63bea0c1a2cb0093042c3acdc429def40d6edd709bd9f9b8e034a090206ca3c399ce6caacdc2e18ab096e657718e24b8859fbcac14a0159180eba29e22a02963d784dbbb61f0354336661cecee9133e7e202aa678c6c20b97577f4d391d1f626067382f4885226ef045ad2d3aae8c3c1234f240b0ee4eba13c0045b403fbabded9cc2c7bea2bdc30451620125e15b8965441742f1d4bcecb19a757cc70e075cbf3998c138c39da1598eb7068a01c14168904391706fa39f8bee6fc64d929c3b9913a09ccf62db394027d65d7de488a15152bbeb4968f656e39d4bc999b360d573937a20ff3b28e8319ae858f9ab99096124de9a632028eb31c62a281ef1f4df5c27b51ab128598fae490776eceeab731ec0a72e685b6f18d5e633f3214515eebf99496a2ba19823216e721ec355b98df1cf0416346b429c35d373421010b702aad3a0a6cbf79289886ee92ae6918bf6d268a933a43ece9009178a2a4a948bc3120738dc58ac0de6d4f66bd83f1331c370fcba38cf060a63993907a2d5dc5ebdb9b3125f55c70c31c529ec20234c94065f8d15ccd0141d228e534130de5a7982b871fcd48994df7cf146d4ae184a65273403a29bbebc09895becada32b88d04e99626d63b2270cf7b2de11b9501b813ff2baf0b56ffe0c662f57a262717232de3bd5e24d96742c658587a8f22807b002d8274569e82375ab13bcff10fb4dca80c0fe740d865a7e6c56d319d0eb0917c4fdfb09db4de2c820b87dad0e63b88b1a4427a89d047bd2096993b373845914581004b55f738ff102fc15c110c6f6f1f5b3e93589eac615946fe7058e75b59fc4c48406785473d13c0083d1ceeda8eaf1cf0739e2be35ac23d67c07a9d00fbcb8cd1ac450c66582e0e462eeb8b77912808b58327f3998d313c365ae873ee3e7be135736b2208ca3d52d1a464cc2c14e6d2931aa3223e4fcf68fc80485d401bbf02d31b0fb0742b3c91ac33a36c70b459ad875a8e042819d9f49fc79dbb9e21663b1892104c68750d5900206cac3c6de3dbb08d7f7ab84f3cec630aa0ec5b69c4ad4f30da3993e8f24e520aef7cfe09074d49a8fb0479902aa5900c575f069ecb36bb549e57fb07643be7136e3cc2be4848c6f1b683a978141b19edc6c2ac1200ed7e0558c597d0bc2ac5be47e15aefb6a7dfedd681cf0e4a53ea8ad27c4afe375c771b42ecaf70e40f6527086cef0ca0b370892a70466a3acb90bd4c5f0ff9df8653180ab87a79875be61b2aa7a0a0b1fbcbaf0a4c306a1620ee3f3dcdfc7bbf4a233178edaa1aaee5a1f03c672503d843c9c9884d4fba68bade455647dba7789d6b228d4ec490ab580c63b31084aba60110a3b391335ac8d7a97f3eb86cda9a59d53bfe72bcdab8bc064c30f58ae5574c6a0157fb80b2865fb2b03146ab4e440a6570ba98aa890cdb6983e357221fd48957adabd754f8a6266121de3797d3f87638331f6690759c5604691b06e256e2f46a7ea85925b24295fc91a6d599771a59105e93c2cb29be18cb439978da6820abb09f23da0368e13de036e6fcb37ccfabc272cdb384f02796df6626c41943f134f655e06598f1f1c2175cd1fa045a2bec71ea187b9361e97fdeac99e89f9e555ce5cb0cf2f79a3deef90f3abe904ebfd2b3fdea49b64dc67f918f308d82fb55788a350c738bc3e254dccadd0f3937535d41956cfad458edfeb6398e1a6769ecc04f6bee3c6e81bbcea95a52df01d42160ab8a3f62d5ac3110ac525d5927e9a2b54fce5ca763b94cbb233934ca36072192ec4475796f11ddbfcacce59ecb08d14b372c84d66622f554c274418714c6f898a42b0dd82e89891cefffdc191f26f995d3acbb01a12021ed0433a7fe89d882c01a8f00155ce977f0d3fd38b9ae58762f993225f77b8827009929ba9e9307fe1561ddf62c004eb620e0c104e1ad554a1a39b7c73d2f817a83144b0cf0f56308168069950fb0975338fee390c2ab44f6d0c5ce6fa2b0f9cec4711faf4f9327eff30a5928a844e441088533e83698a10441df6fc5ff82240c899cd76713bc523dedb98b0286e435544f611b249706c353d72cacd406955ae59fba742f08a3bf2afb91bf41983cc0f11a2509e45a81ab20cca8b8a9a41ce16b2bfba66ed5a8ea59c17a762fa87a698051be18f501833e38ba781b28eb414d1c555844575aa93f7a181dd1f0eec25958cd2da76f3c1dbe831b933b0f69046a1a69dfda9e573fea31b9b9dbe5263c2589d34042cdbc64e50c13d5bd61cd6488650d2290827f7c7e2d449bfb35e39a9146dc763aebd857b8d12e751a97c760cec9640c83596e0d4544791b2a500466f8a5e8735e331921249b8eaba8009876dbbb3863065b71c6917e0eb25df5cc7c51ef4645fec678ca2b7fa6e31894440c8cb3df7f0f9acf7472e8ced9e23e0042c1f5028071657b581d3a93f5c5f99c7bbebdd04848b52214afe698357e82ea0bde07b4826a0895f96a3536debaf2b6d62363691dc3d9db08c740315ed4f3ef26b9bcc1a6db019b6c25b47ec948d1e90b04cfade3ade9f2c189dd6e5f635f6132b2c38a1cc6a5a1aab039209ab4e0ddcb7b24a4cf4ca2a9b902fc6700595edb8fcd8922171d957a725d30ba7bfae353f70c6b18f8149ebb2aa56a1cb072b71ce49df726998106e16a1775be7d19593bab32fd078b07474c9aecbbd9c37f2fee457a600cfb94bbc1ea0b91f1b249ca7bb769af797cb4562308f3e4ade542c298a8591667c634abde4795853d975275254919dc7a45083c0a55c58061386cd3091c0c80572fcd0905dc2663c466714fdd3cbcaaf47d359a9b4d04093b53143e8e382bd1d5bff201e45738ab1b690bb27f5e29fe74cda1a159596b2409aeede36abf906d8b948973280fa4eeb1e770673127c34833222e17ef26830a4198853df6fc4aeb668c47f027fcede2ff6b9aca119eca2d91414b26dcec27a14aa7e33a20c3185c135c684058be12a711eaa930f9a3c2ca902d176e4e133fe6db93a732443648fc224789f89d14599f2f166fa5a9f14dfa954160dbac377214d7f651af2f18dd81743efab183ce24b7d61f261b1b218562b13c91667c3d2fae50f8c2d1241392f6c9b1856d970f8eee421c6dcf0ffbbde0f81cc017eb3b8f5c59e4ae29de10ce5dbbeb291173ea9ab86ffd3517bdbb8f4cf8b1cff1128969a3173be0518cdceaa826f780fac1adb747943ed092b4706f99299196d1a19be7db5a2914ad88216f1f76ee96f0a0919a293d33daf80dba99caca443633149e1128d867a863d829dc4b92b5c3a531a3c8233228bd97cefa21c70bac896b57013af3124d8bde9bf3dbd34b231637ff1a788a6a581b605b446dc32b73fd9b57a11a047a84e9e337f40ead89e83a92c6a24f61f0025b139bbe6dd220e47ac78dd554ae5448dfd272e3679ba864d290b2fcd9ed0f00e07906c55b09b6099eb8dd039e7df93d73cd0ef36eae9b5cd9cb7ea0375021d0b48657177a754058bb900a7262d38d0145b893c6036ae8bbbc964cc94b28deb19343eef1dfc5176cef9043618bbe74a9caf08e8797df7341a7d5b3f595c73897c25df97d20b85afa229781660fe51896cb350e1fafdf19ed7f0d585703149f3d65a911c09e3fc022e2792c63d45543a51aa27071e306cc27e7e5c0ff7aa6560cb106e231d49b95df97986101c558699159a6f24370b41d23c3139d077206ca35948ed5249033b43654db9399a0a8fc08b2272cd41fcb2715ba79a26cec7485175830bc7002a5b2f8117abb5db2e925ba865bbb673d67bdda35874fddf5429106768cf72fcb512e6fd44aa3df81fa15145a055bc4937466e86c55f2c7399aed73a891a64ab64deaa7f17ef7503fc47b2d90bb933671d95f556b41f0ce21a25c45c4c162ba9d7c07eba53bc4cfd6c6bf6a2f7af028a1ec6b7f233414060ff9ac3c36076806806749879af25b815cec966853ec1db31dcb5553494e3be8a9bfcb9f5afedff2c355de8d15174a1c7cb2f38f1c41c282de9035c1b1ecf6e0649ac3ea3b79f2a1db74dafdf50091eb3cf21112a62d20bf14c59c759211a8b2510f28ee4d5dbc3853e949da784f01372134d0ce43b85af658a94db8a02675a3a508060b3b996cfe55bb93e7962c343eeaec5e3b2a077a61753d7a2149dbb31fea1ff014d423ade5e8d6c6568310aefb0e355300983b8e66afd24092b0a4f9b4e00def4f4249d7bbe923dc022d4c7ec678c56371d62321c54b8817067f81e713888cb8f82e84fee65d4f7d4a5e7682a050260b37749abb3b66e6a0657f8ec1ec9023324e92d87500dd992d3370a21b1716a89fac704999bca97b3b1cdd84a4a4a3e71d7f81752ca9cb85efefd2e494a9df4d8cd3df73020be0fd00370ab55015800324f3ff7789f24e2efcb5d308623b5394334d4ae737376547042b957bb538c455ffcd1b9d54a657f6ca144bc5b808c927ee08f983768d60079c880de775ab9bc346d3bcc57b74d8c28636019ae3f2854314076b5abe259f12a3ff08c3de4dd2e0a03b2e2c36ebd4c464a08319fe7924fecedf31a250e52155139771bb53bc626cf497e71671b51bc9371063b0c70160e55cad39f65f6483853457b3f3ef7aaf74b51078d5177e12e4cd1bc9001160ad36de88b8002c4297a115e82173b6e5858469114d57e1fe107d672ddab7903cc6e6a693d4b7c19d3a2466eab1947527590948ccaa71e1bd4abef35e0172000a93894bf61909d7144364f7e43aa2de5c3006f5c7a45f6bcb4edd87a742442c1e8756b5223438ba938f998c0a7f9d07697ac849676df3119aaa1f217e87257b7af95adf2d7b7093e7a7b30c965df788fbfc0891e8e8a756ddff3d111ba9805cf967f6961df43b44b1a83d0ebb23c8238e0ead67cdbb007f18e52f35eec970d99f117d6bbb968e6903047589146c660ee8911404ec6bef25155c7abe77b43b71a99c306fa9d51bb408bb8f7f2bf05ff263db4138e0e76c8c2eb5410a176d99350c7fa4a96c660ea3db6d31714861313359f1323919814231bfc838328f80df3ce774dadca57651d80038a115485d3dd9ec39edc1684722dc2ec6a853c29e9178b176ab1be56b46f4320b3ff2c7275d7c854acb689f94617f0d1d005767449bc1f74c2b235a603150ed079fab7418e8709e3f0f1b11263bac166a70a198db473654a798c7688f5704d926ecc95dd770ac5d7b53c0d1f7cb71a6089fea2127b20ff37aba75607cadec79fe76363be08263c096c61c34efd5785c814858451aaf9e4aafd34b941024a2da8a4252c585ee71c8d082c0d854d89ceefacfcae85ac00d930de6b2112b7ad03d60b5472dec340b6557d230b586b48375527c71071d84a2ad580c4735a469ce35e973cd75d6ac89d225363bef3ff9dc1b5dd28739e0bc50c2f39c2923f9602aa4e95645a053a5c8006c4ff1d15d83d80d7d3e237492ae61bec653212ec47c2823c241622d5883985102f4763cbbb9f99d4831ed7ca12e81f461016c8f3f4450f2b496b473fb405a69a22900c46f9f0332acd03a6af2eba188acb238815b5867173a2697bd7c062e7a5b96223c7c18f183fcffda9a23c185594f0911ca606dec50c4aa2a9baae0c3c5549e9029d77b6ce2d83f93ad6e9ac3e3e60246fe4fcaf0e044f2c505558c9bdc6d3fd37074f24035ebde0a40a890d6c26572104985f78dfeaec04d03c31146924c16d1b8ea71ea298f6a19d4da6e132d0b65162c4754dea600e04cffc3ba964b292d6ac6225f1c524fec3c0a5bb5117d191f44f615a5db013dbec9d558a9ad814bb52a0d56b3b75cd0318d6b413182a72c1b66bf92905229c6bd1b697afebe2cebb2d95a9eb37e2c1bf15c346bb937124e1eaccb58e6f9487455bf11c3950b2724e8a16c4b02049619c33810fb5381c0e10776143b9cfa98aec508336d4019749fd5a72ef34c3e8b549a1b535ec1c5889a98c2e7d1d5c2090b732e24a96b75b70e7765618b97a88d9da8ffd646d9e2b9782e1e2723246b092014dcc19b24b247d5c67f8afea83877c864c9a0909e141bd8412375aba3e8ae7dfb80c384dfd88bb978494c1ce374dade76451df14d1f328db6a48d101a55a0e30848011f5fa2d489e6eafc9c7ee8e9e86b719b5c74930ae7371c3764880c22123e073189a7ba44f56682d789aca0df1abcda9230eef8e1cf0de59415ea2cbbb285bc38b08b4b897ce85a2d65618e64279f785f82856a798dfdd400be59ee73955b559b72efc5f386da633387655f50e1baf7f9b28377c0e161b45f80b8c70ba9b8150a1f906a0234839205ffdafa90a571d29c5ee161729f065c04c58bb19d87a918d9d4c9cda9ac2bcf738e28402c1f6e918e5e06799d708766d6a17cb7eb9dedc19c577f02d6a97628fda67e814ed8eb3e2d33768a7eca8f8fdb1733bba6227cdecc548f2ca7efb5bacda0fd84ccbd21f075abeee534fbf0f458dd27a8847b906cea530a6f268e7a24f662a167774446829768f5263fbfba689f744709485be2d3a3d3cb66fb79f5fa6b4010e4fd421641f8b131c8bb823d984ca71314e84660e37f055f6bb33c95466ee7ab2f33def83c58fe81fb9858660e28751a7d8643fb8f7923403cab8c05c987734b52ca06e7936708819c74e73f2e07d22074c450d705a6ee7dc83efe9c6209bf8894a8919ef6b2df578f585e87024763955e9302044dea8e9a130a09a59f2fe0d4509b42ac4fdf0bff9afba0e53f6896169c2fe236cc833c988bfc81b67fea93a5290d090bdb5e216a600b6dc1f1035e63ce73af3b47cdd71b5091941cec00c7fe280e7ee9bc2d21d5567d2306f1aff312bd0f6b21fdc53e20458856413d9199d8e498c0471671e4c1c53c1e927fe7edfd99c06d6331075b039905793811f6a6f80e6a54f5c0a298bd62280c0fe7eaf05a50dbce6d4f6af4c8d644016be54121ce973a27ffcc498a78492df7803b385bc2ef226a71f210cb5f132cf100bcd13fb542debd4333c076509e36daa64ebf4260c18f97bd0ee8c2f48ae820c9bf98cb412ad779ba1c787561519873504a92fe2642b8304b28563c2613855eebf4cfe41fd4ee9b44be4555c4caa82d9f306bc1cf18cedfec139c5c2be3d8a25bb21d1e2cbc181a53a91a6c67f7b74562040ad2173bd1423fe5d04cf5c8e112e335cf5e5d3ef1e7041e1d58e0c82c063759cd8cf17ae317be889bd98bf2d5ac88d953593530b7fa801856a19f5571c9d5267a1d67f0dfd3d37e1f3dbd320764630a88da54a51b958e7db10a18983e0dda8cb9ef2f3e2709b408549921b245ea26e3828e82aa520292e19f178dcb5125d157a2165db795454324a73cdc6d81d3df02d6be3cc4cdf0295059b33a0a51f1c54281bcd9f8316e29439ebcd5960c0dbb6b9e07bedb66d38b133db325631fecb93007c9c139d8635054bcdc2161ca6fc83c8be1f0bddd05125555d88ead44559d2672f3ffd5a3f70cd1acbd2133db94d6bd54441aa3d22a79f1affc9d2ad53d9352afd21a50760a2af6416c9139321c845cb54ee00e32b7e534bbd4a50e0638a4775d26cc03030a75264e212e8ce84325e8d17dfea48b4cde74b6192c6f1dd7bee37ec9c91b462f91d03251878eb9195da6d5164e9f152c2fa637c1d0b79069585468e89e2f94b4e3dd8ff2226d7c9fddd7ac47aa01f410dcc0ca4548295900738537f9f5a429272c2abbdfa3652f0f6ed6db478a98cc50892032d706bfd6a19450961cd61ec06131ab4c8d73c5959e8120cd5c5effbf6f0a6de1b423b6fd74acb09bea76c0050c1984e37c6c12a2263b2ad25abc7bacf83ada8ddc9b72108fdb626c833127de25a8aa820b32ec14d0917f494a69f6b8c7a3e293b36334c93ae104b4766dde781c1c27df1d299bfc2a5d560a1c5663980cc78ba77ec37532b5d70946f6087b5d4d56e275655bf65a27f41e0d25030370ee36cdfd7b1df5b58ecdd279115b9c37620e8dd3b023c7bb6fe1226b004baf627fff493586ac91e53553ce5d7c2418b1c5dcded459f4af173b4a753178d7aa98523910db501abc95d86740abf0a43646af9508efaf51d14c006c7b274cfc7690033724d88e1e30a726f7f229ec0e8b14b27273d946792634227687dd39bfd14d0cb5e8783c0883201b30e36e7808ba5a5771fdd610b48033ad018607aa0e64595a1588161847366541036eff9e30f7d7d8f8ae3bfecd9546b4166b515907edf23d33acb8ca23f5f5bebe16ac1a10a495a6e1b357bfdc5f19da9f53fc33e5ce2781a6f60b7cb64e58fb802cca5677d7f69b0d8013f959ebf6bee80dade07dfb1f9cdc20f25a9dcc2d410958bb3e4ac868fae58e35ecd218dd81b6b5712a78a49c8792445a56ed02ad9a78beb708a20215b3db29b76ef56a2c2b0bb6f25966abbb6409e1c1e77847369f677c1e5d35598864fb28942133dbaf7f434fc26a0b10764d324274564376b34a4a7c75faea5a85278deb7617218ed3804175cda5bc1ae09b3e7cf8fc50f3c28662333c0117977b34a5e166893606544ef0c4f2eb546fc1b9746516351ceec26ef0fe1d671dc506c325e394c460f22e40f725efb4f89abcb1af78ffb2a2618506b0a463d02d309cd9a550d580791d26ab79717716fae5bfb2d450e2ee6c10d93c7d0cf1c340815c78d6bbc2afc57d6b35a4b74f098d985f7265ed7174bb374d081b86ed22d8392b5738c6b17e99bacbcd78874682824c9a217dce5d417e78c0fc2d702bd457eca81b78b298dc8e4746c900b79a69d2b70cfaed2b70c4fd222ade9b2972122a708c7cbcb645abf930eaa830325ab58a10f1f8df4773b6410b1b464a2d722de40a8c4ffa6da0292e5bb16b491b43ea934d32af540e68ff6191356b3f8e30aef36aca80d455f4247bbb378a63bd3eb17a7e8b5edc32c35f3829acd0c4d7f9c0100b37053641e7aaa82fa41d91f787126dcd5eb6dda64dee6d0a06b6e3da29c900cc8aef5575914cda2bbd2773951c842b82f1617e089be429f89d49f7420be71b37d6565e4d095108795779bc7d89e200442651a49bf08f46120542cb4c68e6c7454cd3eebcece3130dd07732e886e777b0e9748d44832a0a49d3d9e3f64f2d8b24c24315120f369962c5320d340984167f0fc9376c095c43164c21a6d4d648049289d72090e19de01df4240bd4f9f4d0b90f73efe51354d28d87a5d22eddb6cc524d91c51a3454efb6eecbb14a7fd0bc92064da745faac1e45e43446b6f240e35ea0ae205ed461f6b9dd4309faa59b02962d915704a962da6fade0e614b4d70ff99b5feb2cc352639eb2072d93d0857f2497e4a8d133b96981c62ebb54a02725c44db07f653a763543136a804f8e56943c7cfb15de89facb9da73cd2360882586b89aeb1ec859217f825e39a26580c56ec3d86ef12359c453964db434b979a1068632512029131db73e08b2af84200521d558b5b72034b450dffcaa21d4df5e7caf3b562b81786490671e19a228dddb31c915cb5e91b81036411ca82c3d0ab51f884290763072954f0e05c85ffb198e73c10e844c32bdc5dca7213d602289630f80321d3da6405c27aba86df36a9de7a564a5a4627a6a78db33d0fe71ff214ca77efae2f70c69ed0ae7217c84fa128fa990c195047f9a408f866d17accfbfab18f0f5d772e225108564c5d0e91cba41a71c8b759f6d59376cb6243b88e849165160a0d9a393c4f3bae69aae492049c0d7f89a659864a647e399576ad13305808991dcf6c07701aa17875e08a809432f0e8bc3b49042403d9f245dd1e195ec755eb8bf352a10717ef35436986652dec9cfef5edec46dff2c6cb5f10bb10bc4014dae1f85c84570bab466ae5deaf0328a1b95b3db1b7d3455715515e61cb7b3d5259b403b33339275e0cb6ebdecf68d3af9ac75f758914019d4fea1cefbc2346d4b8d7121dd4d878d30dfe61bbefe0062aba292149fad19a5bc49022f600cc3747dcec84d71ec684f4e88ee7ed92dbf2b8093bbf7852f21932dbf336452bf3d4c63281a3ce51f9e313fd6e0a53c34634118173dc6fa3527abf8d31da80cc7e11e21bae3d051b85fa5592d998d12c15ff034d8fe8af7793c95502338823a2a10a096cf3af59158ebbee0b16c2809048cbf7ca3470ab8873f8c049808e4e0fea0afade35d481fe1b10f8600e3ae00a85d7ea38b9814abe3e25dfaaacdcef82a2451fc3e99a89447adcbfd063c68431a66822643294ac18c123cf8c2c4e829782500dc2c8ba75460eef150e7e5b72344351ffe8ffa3aafde3c2728320997f1423f204ccf365a419267f4407c87fc6acff78fff1af59c6d6428796c868fc9933da83daf14f434b24fe84a40f49035ae0eabbed88114bad2334392e99774b9ea089e6b6174e53865d69b122c5e79c0204bccc81fefbfd6232ae834f15a1b156edfd19690dc18e177e9b5b1e2055242ad3c7178412a1bd8ea18deee66a3839b01341c37a49d08cc921949a0cfc729675b006765f1fd534e7f29feea58789fdc76097c6ac3ceef1b4b55095e11f3aac2fcb900f142bae9e2d062b60288cae631668335a59394f49949bcfa0db7f864550dca304dc0a3ea8dc6f95cc98d66a3e8eed2a639cc40c11b2c59fecd694c082867103756bd4714a4c2bb555057543583f057831c989ff2f5990f7338ef697dbde6be0c24a2ef81bc16718f51519f0fb6a38964dc669f2f467169a01d795fca887c42de8a18c4900de90beddec12709bf86b847fe7097b65c8d49ac7ba16efd22fff1d5ae212a1a33ee71a022710cec01657066240d5699789f451e10eaac6bb4f5f3ca7954696578c304443fb8c13a1b5695495461b5512a15041947a3b2860e7bd06614e603cdb518cb79c97b3687cd8bd5d22bb86c7a4272739b01e449f3441b8a2bbd9e2a1d68727056d5b19f9a08005bd23071b6aca32e9608ba9c1b640fb972a2cc654157dadf0fbd55d38effafe785e89f893d9eb1076fe44096cc6a1874409e95363652cece26e202d0c895274c536663","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f36426841e25f2f5e7a709d0d9034e49"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
